import Mustache from 'mustache';
import { deleteFromArray } from '../helpers';
import { Transition, Element, GatewayLabel, GatewayType } from '../Parser/Element';
import InteractionNet from '../Parser/InteractionNet';

export interface TemplateEngine {
  compile(iNet: InteractionNet): string
}

type SolidtiyContractTemplate = {
  numberOfParticipants: number,
  transitions: Array<{
    id: number
    consume: number,
    produce: number
  }>
}

export class SolidityMustache implements TemplateEngine {

  compile(_iNet: InteractionNet): string {
    const iNet: InteractionNet = {..._iNet}
    if (iNet.initial == null || iNet.end == null) {
      throw new Error("Invalid InteractionNet"); 
    }
    const options: SolidtiyContractTemplate = {
      numberOfParticipants: iNet.participants.size,
      transitions: new Array<{
        id: number,
        consume: number,
        produce: number
      }>()
    }
    
    // remove start transition, as we assume the init of a contract
    // is equal firing the start transition
    this.deleteElement(iNet, iNet.initial);
    this.deleteElement(iNet, iNet.initial.target[0]);
    iNet.initial = iNet.initial.target[0].target[0];

    // remove silent transitions generated by XOR transformations
    console.log("remove");
    for (const element of iNet.elements.values()) {
      if (element instanceof Transition 
        && element.label instanceof GatewayLabel 
        && element.label.type === GatewayType.Exclusive) {
          console.log(element.id)
          console.log(element.source)
          console.log(element.target)
          if (element.target[0].target.length === 1 
            && element.target[0].target.length < element.target[0].source.length) {
            // converging
            const targetPlace = element.target[0];
            const prevTransitions = element.source[0].source;
            targetPlace.source.push(...prevTransitions);
            for (const prevTransition of prevTransitions)
              prevTransition.target.push(targetPlace);
            // if the element is still needed, don't delete
            // just unlink it
            console.log("converging")
            if (element.source[0].target.length === 1) {
              this.deleteElement(iNet, element.source[0]);
            } else {
              console.log("just unlink")
              console.log(element)
              deleteFromArray(element.source[0].target, element);
            }
            this.deleteElement(iNet, element);
          } else {
            // diverging
            const sourcePlace = element.source[0];
            const nextTransitions = element.target[0].target;
            sourcePlace.target.push(...nextTransitions);
            for (const nextTransition of nextTransitions)
              nextTransition.source.push(sourcePlace);
            // if the element is still needed, don't delete
            // just unlink it
            if (element.target[0].source.length === 1) {
              this.deleteElement(iNet, element.target[0]);
            } else {
              deleteFromArray(element.target[0].source, element);
            }
            this.deleteElement(iNet, element);
          }
        continue;
      }
    }
    console.log("remove done");

    // places to marking ids
    const markings = new Map<string, number>();
    let marking = 0;
    for (const element of iNet.elements.values()) {
      if (!(element instanceof Transition)) {
        continue;
      }

      console.log("ID", element.transformationReference);
      let consume = 0;
      let produce = 0;
      console.log("EID", element.id);
      // collect consuming places
      console.log("INS____");
      for (const _in of element.source) {
        console.log(_in);
        if (!markings.get(_in.id)) {
          markings.set(_in.id, 2 ** marking);
          marking++;
        }
        consume += markings.get(_in.id)!;
        console.log(consume)
      }
      // collect producing places
      console.log("OUT____");
      for (const out of element.target) {
        console.log(out);
        if (!markings.get(out.id)) {
          markings.set(out.id, 2 ** marking);
          marking++;
        }
        produce += markings.get(out.id)!;
        console.log(produce)
      }

      /* if (!element.transformationReference) {
        console.warn("Element without transformation reference, skip", element.id);
        continue;
      } */

      options.transitions.push({
        id: element.transformationReference? element.transformationReference : 999, 
        consume, 
        produce
      });
    }
    console.log(options);
    console.log(markings);
    return "lol";
  }

  private deleteElement(iNet: InteractionNet, el: Element) {
    for (const source of el.source)
      deleteFromArray(source.target, el);
    for (const target of el.target)
      deleteFromArray(target.source, el);
    iNet.elements.delete(el.id);
    iNet.transformatioReferences.delete(el.id);
  }
}